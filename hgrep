#!/bin/bash

# Help                                                     #
############################################################
Help()
{
   # Display Help
   echo "Usage: hgrep OPTIONS... [FILE] PATTERN(S)"
   echo "Search for PATTERN(S) in file or STDOUT"
   echo "Can search for multiple PATTERNS"
   echo 
   echo "The recommended order to use flags is as follows"
   echo "hgrep -H "0-9" -l -i -f myfile (-s or -e) PATTERN(S) "
   echo 
   echo "Options:"
   echo 
   echo "-h, --help           Display this help message"
   echo "-s, --search         Pattern to search for"
   echo "-e, --multi-search   Multiple search entries (hgrep -e foo -e bar)"
   echo "-l, --lines          Toggle line numbers that DO NOT correspond to line in file. Useful to quickly see number of matches or clearly distinguish seperate lines"
   echo "-i, --ignore-case    Case-insensitive pattern search"
   echo "-H, --headers        Number of Header lines, Default is 1"
   echo
   echo "Example syntax: hgrep -li -f /path/to/myfile -s "pattern" "                    
   echo "Example syntax: hgrep -H 2 -li -f /etc/hosts -e "example.com" -e "acme.com" "
   echo 
   echo "More Examples: "
   echo "lsblk | hgrep sda "
   echo "lsblk | hgrep -H 1 -lis nvme0n1"
   echo "hgrep -f /etc/hosts -H 5 -li -e "example.com" -e "acme.com" "
   echo 
   echo "Do not use header AND include first line in search results"
   echo "hgrep -f /etc/hosts -H 0 -s Loopback"
   echo "Specific Special character searches that need to be preceded by triple backslashes or single backslash inside doublequotes"
   echo "[\\][|]"
   echo "Search for literal \\ by using quadruple backslashes"
   echo "Other special character searches need to be preceded by single \\"
   echo
  
}

Help2()
{
   # Display Help
   echo
   echo "The order to use flags is as follows"
   echo
   echo "Syntax: scriptTemplate [hgrep (-l and/or -i) -s "pattern" "
   echo "options:"
   echo
   echo "-h     Display this help message"
   echo "-s     Pattern to search for"
   echo "-e     Multiple search entries (hgrep -e foo -e bar)"
   echo "-l     Toggle line numbers that DO NOT correspond to line in file. Useful to quickly see number of matches or clearly distinguish seperate lines"
   echo "-i     Case-insensitive pattern search"
   echo "-H     Number of Header lines, Default is 1"
   echo
   echo
   echo "Examples:"
   echo
   echo "lsblk | hgrep -H 1 -lis nvme0n1"
   echo
}

NoInput()
{
   # Display NoInput
   echo
   echo "Need to pass a file or command use "hgrep -h" for help"
   echo
}

tooMany()
{
   echo 'Invalid combination of options --   '
   echo "Type "hgrep -h" for help"
   echo
}

tooManySearch()
{
   echo "Can only search for a single pattern unless "-e or --multi-search" is specified"
   echo "Type "hgrep -h" for help"
   echo
}

lflag=false
iflag=false
sflag=false
eflag=false
hflag=false
Hflag=false
qflag=false
fflag=false
entries=()
or=''
# If number of arguments is 0 Help message
# if (($# == 0))
# then
#    Help
# fi

_hgrep_completion()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--help --headers --lines --ignore-case --search --multi-search --file"
    opts_multi="--multi-search -e"
    #echo ${COMP_LINE}
    # Stop showing options after selecting option that requires arguments
    if [[ ${cur} == -* ]] && [[  ${COMP_LINE} != *--help* && ${COMP_LINE} != *--search* && ${COMP_LINE} != *--multi-search* && ${COMP_LINE} != *-e* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur} ) )
        return 0
    elif [[ ${cur} == -* ]] && [[  ${COMP_LINE} != *--help* && ${COMP_LINE} != *--search* ]] ; then
        COMPREPLY=( $(compgen -W "${opts_multi}" -- ${cur} ) )
        return 0
    fi

}
# Complete options -d for directories -f for files -F then name of function in this script last argument is location of bash script to bash complete for
complete -d -f -o default -F _hgrep_completion hgrep


# NOTE: This requires GNU getopt.  On Mac OS X and FreeBSD, you have to install this
# separately; see below.
TEMP=$(getopt -o hf:H:lis:e: --long help,file:,headers:,lines,ignore-case,search:,lines,ignore-case,multi-search: \
              -n 'hgrep' -- "$@" )

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"

while true; do	
   case "$1" in
		-h | --help) 	           hflag=true # display help
                                Help
				                    exit;;
		-H | --headers) 		     headers="$2"; Hflag=true; shift 2  ;;
		-l | --lines) 		        line1=" i=1"; line2="\"\\033[31m\"i\":\"\"\\033[0m\","; line3=" \$0 ; i++"; lflag=true; shift ;;
		-i | --ignore-case) 	     set="IGNORECASE=1;"; iflag=true; shift  ;;
		-s | --search) 	        if [[ "$sflag" == false ]]; then sflag=true; else tooMany; exit 1; fi; pattern="$2"; printer="print"; no="";  shift 2 ;;
		-e | --multi-search) 	  entries+=("$2"); eflag=true; printer="print"; shift 2  ;;
		#-F)                      Fflag=true; ;;
      -f | --file)              if [[ "$fflag" == false ]]; then myfile="$2"; fflag=true; shift 2; else tooMany; exit 1; fi; ;;
      # --complete)
      #    # shift 1
      #    if [[ "$TEMP" == *"help"* ]]; then
      #    echo 
      #    exit
      #    else
      #    echo --help --headers --lines --ignore-case --search --multi-search --file
      #    exit
      #    fi
      #    ;;
      -- ) shift; break ;;
       * ) break ;;
	esac
done


# shift $(( OPTIND +0))

if (( OPTIND > 1))
then
echo "Invalid combination of options -- ($-) "
fi

# echo $OPTIND

if [[ "$sflag" == true && "$eflag" == true ]]
then
   tooMany
   exit 1
fi

#Check if headers option is set
if [[ "$Hflag" == true ]]
then
   # Check if header argument is a positive numberical value
   re='^[0-9]+$'
	if [[ ! "$headers" =~ $re || "$headers" == "" ]]
	then
		echo "Not a valid argument for (-H | --headers)option, need positive integer '0-9'"
		Help
		exit 1
	fi
fi

if [[  "$Hflag" == false ]]
then
	headers=1
fi

# Check if passing in a file name with -f option
if [[ "$fflag" == false ]]
then
# Check if stdin is empty otherwise awk will hang
   if [ ! -t 0 ]
   then
      # echo "stdin has data"
      : # no-op
   else
      NoInput
      exit 1
   fi
fi

# echo "${entries[@]}"
max="${#entries[@]}"
maxless=$(("$max" - 1)) 
# echo "$max"


for (( i=0; i < "$max"; i++ ))
do
   # echo "$i"
   if (( "$i" == "$maxless"  ))
   then
      entries[i]=(${entries[$i]})' '
      continue
   fi
   entries[i]=(${entries[$i]})'|'
done

# for entry in "${entries[@]}"
# do
#    echo "$entry"
#    if [[ "$entry" == "$last"  ]]
#    then
#       entry=\("$entry"\)
#       continue
#    fi
#    entry=("$entry")'|'
# done

# Check if used -s flag to specify search; If not then assume that the input after hgrep [NY OPTIONS] IS the search pattern
if [[ "$sflag" == true && "$pattern" != '' ]]  ||  [[ "$eflag" == true  && "$entries" != '' ]]
then
   : # no-op and continue
# Check that we don't have multiple search patterns seperated by spaces; $2 is the second input
elif [[ "$sflag" == false  &&  "$eflag" == false  && $2 == '' && "$pattern" == '' ]]
then
   # echo "assigning $1 to pattern"
   pattern=$1
   printer="print"
else
   tooManySearch
   exit 1
fi

# Strip parentheses with sed
entries2=$(echo "${entries[@]}" | sed "s/[()]//g")
#String Filtering
string="$entries2"
if [[ "$entries2" == "\\" || "$pattern" == "\\" ]]; then
   echo "Search pattern cannot be double backlash"
   echo "Try four backslashes to search for literal backslashes"
   Help
   exit 1
fi


# echo "${entries[@]}"
# echo "$pattern"

# Strip quotes with sed
entries=$(echo "${entries[@]}" | sed "s/'/ /g")

# Strip quotes with sed
myfile=$(echo "${myfile}" | sed "s/'/ /g")


# strip empty space with sed
entries=$(echo "$entries" | sed "s/\s//g")
# escape special characters        //\//\\/
# entries=$(echo "$entries" | sed "s//\//\\/g")
# echo "HERE"
# echo "$entries"




# echo "${entries[@]}"

# if [[ "$sflag" == true ]] || [[  "$eflag" == true ]]
if [[ "$pattern" != '' ]]
then
   if [[ "$fflag" == true ]]
   then
	   awk 'FNR<='"$headers"'{print; next} BEGIN{IGNORECASE=0; '"$set"' '"$line1"' } gsub(/'"${entries//\//\\/}"''"${pattern//\//\\/}"'/, "\033[31m&\033[0m")  {'"$printer"' '"$line2"' '"$line3"'}' $myfile
   else
      awk 'FNR<='"$headers"'{print; next} BEGIN{IGNORECASE=0; '"$set"' '"$line1"' } gsub(/'"${entries//\//\\/}"''"${pattern//\//\\/}"'/, "\033[31m&\033[0m")  {'"$printer"' '"$line2"' '"$line3"'}'
   fi
else
	NoInput
	exit 1
fi

# Multiple Entries  (sadf)|(asdf)|(asd)
