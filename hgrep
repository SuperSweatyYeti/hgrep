#!/bin/bash



# Help                                                     #
############################################################
Help()
{
   # Display Help
   echo "Usage: hgrep OPTIONS... [FILE] PATTERN(S)"
   echo "Search for PATTERN(S) in file or STDOUT"
   echo "Can search for multiple PATTERNS"
   echo 
   echo "The recommended order to use flags is as follows"
   echo "hgrep -H "0-9" -l -i -f myfile (-s or -e) PATTERN(S) "
   echo 
   echo "Options:"
   echo 
   echo "-h, --help           Display this help message"
   echo "-s, --search         Pattern to search for"
   echo "-e, --multi-search   Multiple search entries (hgrep -e foo -e bar)"
   echo "-l, --lines          Toggle line numbers that DO NOT correspond to line in file. Useful to quickly see number of matches or clearly distinguish seperate lines"
   echo "-i, --ignore-case    Case-insensitive pattern search"
   echo "-H, --headers        Number of Header lines, Default is 1"
   echo
   echo "Example syntax: hgrep -li -f /path/to/myfile -s "pattern" "                    
   echo "Example syntax: hgrep -H 2 -li -f /etc/hosts -e "example.com" -e "acme.com" "
   echo 
   echo "More Examples: "
   echo "lsblk | hgrep -H 1 -lis nvme0n1"
   echo "hgrep -f /etc/hosts -H 5 -li -e "example.com" -e "acme.com" "
   echo
}

Help2()
{
   # Display Help
   echo
   echo "The order to use flags is as follows"
   echo
   echo "Syntax: scriptTemplate [hgrep (-l and/or -i) -s "pattern" "
   echo "options:"
   echo
   echo "-h     Display this help message"
   echo "-s     Pattern to search for"
   echo "-e     Multiple search entries (hgrep -e foo -e bar)"
   echo "-l     Toggle line numbers that DO NOT correspond to line in file. Useful to quickly see number of matches or clearly distinguish seperate lines"
   echo "-i     Case-insensitive pattern search"
   echo "-H     Number of Header lines, Default is 1"
   echo
   echo
   echo "Examples:"
   echo
   echo "lsblk | hgrep -H 1 -lis nvme0n1"
   echo
}

NoInput()
{
   # Display NoInput
   echo
   echo "Need to pass a file or command use -h for help"
}
tooMany()
{
   echo "Invalid combination of options -- "$@"  "
   Help
}

lflag=false
iflag=false
sflag=false
eflag=false
hflag=false
Hflag=false
qflag=false
fflag=false
entries=()
or=''
# If number of arguments is 0 Help message
# if (($# == 0))
# then
#    Help
# fi

# NOTE: This requires GNU getopt.  On Mac OS X and FreeBSD, you have to install this
# separately; see below.
TEMP=$(getopt -o hf:H:lis:e: --long help,file:,headers:,lines,ignore-case,search:,lines,ignore-case,multi-search: \
              -n 'hgrep' -- "$@" )

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"

while true; do	
   case "$1" in
		-h | --help) 	           hflag=true # display help
                                Help
				                    exit;;
		-H | --headers) 		     headers="$2"; Hflag=true; shift 2  ;;
		-l | --lines) 		        line1=" i=1"; line2="\"\\033[31m\"i\":\"\"\\033[0m\","; line3=" \$0 ; i++"; lflag=true; shift ;;
		-i | --ignore-case) 	     set="IGNORECASE=1;"; iflag=true; shift  ;;
		-s | --search) 	        if [[ "$sflag" == false ]]; then sflag=true; else tooMany; exit; fi; pattern="$2"; printer="print"; no="";  shift 2 ;;
		-e | --multi-search) 	  entries+=("$2"); eflag=true; printer="print"; shift 2  ;;
		#-F)                      Fflag=true; ;;
      -f | --file)              myfile="$2"; fflag=true; shift 2 ;;
      # --complete)
      #    # shift 1
      #    if [[ "$TEMP" == *"help"* ]]; then
      #    echo 
      #    exit
      #    else
      #    echo --help --headers --lines --ignore-case --search --multi-search --file
      #    exit
      #    fi
      #    ;;
      -- ) shift; break ;;
       * ) break ;;
	esac
done

# shift $(( OPTIND +0))

if (( OPTIND > 1))
then
echo "Invalid combination of options -- ($-) "
fi

# echo $OPTIND

if [[ "$sflag" == true ]] && [[ "$eflag" == true ]]
then
   echo "Invalid combination of arguments -s -e"
   Help
   exit
fi

#Check if headers option is set
if [[ "$Hflag" == true ]]
then
   # Check if header argument is a positive numberical value
   re='^[0-9]+$'
	if [[ ! "$headers" =~ $re ]] || [[ "$headers" == "" ]]
	then
		echo "Not a Valid argument for -H need positive integer '0-9'"
		Help
		exit
	fi
fi

if [[  "$Hflag" == false ]]
then
	headers=1
fi

# Check if passing in a file name
if [[ "$fflag" == false ]]
then
# Check if stdin is empty otherwise awk will hang
   if [ ! -t 0 ]
   then
      # echo "stdin has data"
      : # no-op
   else
      NoInput
      exit
   fi
fi

# echo "${entries[@]}"
max="${#entries[@]}"
maxless=$(("$max" - 1)) 
# echo "$max"


for (( i=0; i < "$max"; i++ ))
do
   # echo "$i"
   if (( "$i" == "$maxless"  ))
   then
      entries[i]=(${entries[$i]})' '
      continue
   fi
   entries[i]=(${entries[$i]})'|'
done

# for entry in "${entries[@]}"
# do
#    echo "$entry"
#    if [[ "$entry" == "$last"  ]]
#    then
#       entry=\("$entry"\)
#       continue
#    fi
#    entry=("$entry")'|'
# done

# Strip parentheses with sed
entries2=$(echo "${entries[@]}" | sed "s/[()]//g")
#String Filtering
string="$entries2"
if [[ "$entries2" == "\\" ]] || [[ "$pattern" == "\\" ]]; then
   echo "does equal"
   echo "Search pattern cannot be double backlash"
   echo "Try four backslashes to search for literal backslashes"
   Help
   exit
fi


# echo "${entries[@]}"
# echo "$pattern"

# Strip quotes with sed
entries=$(echo "${entries[@]}" | sed "s/'/ /g")
# echo "$entries"
# strip empty space with sed
entries=$(echo "$entries" | sed "s/\s//g")
# escape special characters        //\//\\/
# entries=$(echo "$entries" | sed "s//\//\\/g")
# echo "HERE"
# echo "$entries"


if [[ "$sflag" == true ]] || [[ "$eflag" == true ]] && [[ ! "$pattern" == '' ]] || [[ ! "$entries" == '' ]]
then
   : # no-op
else
   echo "Search pattern cannot be empty type -h for help"
   exit
fi

# echo "${entries[@]}"

if [[ "$sflag" == true ]] || [[  "$eflag" == true ]]
then
   if [[ "$fflag" == true ]]
   then
	   awk 'FNR<='"$headers"'{print; next} BEGIN{IGNORECASE=0; '"$set"' '"$line1"' } gsub(/'"${entries//\//\\/}"''"${pattern//\//\\/}"'/, "\033[31m&\033[0m")  {'"$printer"' '"$line2"' '"$line3"'}' $myfile
   else
      awk 'FNR<='"$headers"'{print; next} BEGIN{IGNORECASE=0; '"$set"' '"$line1"' } gsub(/'"${entries//\//\\/}"''"${pattern//\//\\/}"'/, "\033[31m&\033[0m")  {'"$printer"' '"$line2"' '"$line3"'}'
   fi
else
	Help
	exit
fi

# Multiple Entries  (sadf)|(asdf)|(asd)
